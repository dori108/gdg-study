{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/dori108/gdg-study/blob/main/4-2\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "9tTjNf3laG_2"
      },
      "source": [
        "텐서플로를 활용한 구글넷 구현\n",
        "\n",
        "* **GoogLeNet(Inception) 구조를 활용하여 CIFAR-10 이미지 분류 문제를 해결**하는 것.\n",
        "* 모델이 얼마나 잘 일반화되는지 **훈련과 검증 정확도**, **테스트 성능**을 통해 확인.\n",
        "* 추가적으로 **모멘텀**, **L2 정규화**, **ReduceLROnPlateau 콜백** 등을 적용하여 성능을 향상시키는 것.\n",
        "\n",
        "\n",
        "### **1. 데이터: CIFAR-10**\n",
        "\n",
        "* 32x32 크기의 컬러 이미지 60,000장\n",
        "* 10개의 클래스로 분류됨 (비행기, 자동차, 고양이, 개 등)\n",
        "* 학습용: 50,000개 / 테스트용: 10,000개\n",
        "\n",
        "---\n",
        "\n",
        "### **2. 모델 구조: GoogLeNet**\n",
        "\n",
        "* 원래 Google에서 이미지넷 대회에 사용한 모델 (2014)\n",
        "* **Inception module**이라는 구조를 사용:\n",
        "\n",
        "  * 서로 다른 커널 크기(1x1, 3x3, 5x5)를 병렬로 적용해서 다양한 스케일 특징 추출\n",
        "  * 성능을 높이면서도 계산량은 줄이는 아이디어\n",
        "\n",
        "---\n",
        "\n",
        "### **3. 규제 기법 (Regularization)**\n",
        "\n",
        "* **L2 정규화 (`weight_decay`)**: 과적합을 막기 위해 각 Conv2D 레이어에 L2 패널티 적용\n",
        "* **Dropout은 사용되지 않았지만**, `BatchNormalization`이 거의 모든 Conv2D 뒤에 적용되어 학습 안정화에 도움\n",
        "\n",
        "---\n",
        "\n",
        "### **4. Optimizer: SGD + Momentum**\n",
        "\n",
        "* 학습 최적화를 위해 **모멘텀을 적용한 SGD 사용**\n",
        "* 기울기 정보를 누적해서 **지역 최솟값에서 빠져나오기 쉽도록 유도**\n",
        "\n",
        "---\n",
        "\n",
        "### **5. Learning Rate Scheduler**\n",
        "\n",
        "* `ReduceLROnPlateau` 콜백:\n",
        "\n",
        "  * **Validation loss가 줄어들지 않으면** 학습률을 줄여서 더 정밀한 학습이 가능하도록 함\n",
        "  * `patience=4`: 4 epoch 동안 성능이 개선되지 않으면 learning rate 감소\n",
        "\n",
        "---\n",
        "\n",
        "### **6. 훈련 및 평가**\n",
        "\n",
        "* `model.fit()`으로 전체 훈련 진행\n",
        "\n",
        "  * `validation_split=0.2`: 20%의 학습 데이터를 검증용으로 사용\n",
        "* `model.evaluate()`로 테스트 데이터에 대한 최종 정확도 확인\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 230
        },
        "id": "9IjQnjqxaDND",
        "outputId": "9fb3a423-7938-408b-dc3d-8f408a38b45e"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Downloading data from https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz\n",
            "\u001b[1m170498071/170498071\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m13s\u001b[0m 0us/step\n"
          ]
        },
        {
          "data": {
            "image/png": "iVBORw0KGgoAAAANSUhEUgAAAxsAAACvCAYAAACVbcM3AAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAWw1JREFUeJztvWmwJVd95fvPM4/3nDtPNQ8qlaSShNBEIYRAdstggeU2jUzE8xD243U4cNvBa3qw32tD9CO67cZgAtPPEObZjWxHgBsjDBLGYCMGIyEhoakklapKNQ/31p3OPfOQJ/N9oKVgrZ2WLkjnXlWxfhH14X/uyWnnzp2ZddbaywvDMDQhhBBCCCGEeIWJbfQOCCGEEEIIIS5O9LIhhBBCCCGEGAh62RBCCCGEEEIMBL1sCCGEEEIIIQaCXjaEEEIIIYQQA0EvG0IIIYQQQoiBoJcNIYQQQgghxEDQy4YQQgghhBBiIOhlQwghhBBCCDEQfuJfNo4fP26e59kf/uEfvmLr/MY3vmGe59k3vvGNV2yd4uJE/U9sJOp/YqNRHxQbifrf+nBBvmz8j//xP8zzPHv44Yc3elcGymc/+1l73eteZ/l83srlsu3fv9++/vWvb/Ru/cTzk9D/PvOZz9g111xjmUzGxsfH7dd//ddtcXFxo3dLmPqf2Hh+EvrgD/PTP/3T5nme/eZv/uZG74qwi7//Pfvss/be977X9u/fb5lMxjzPs+PHj2/0br0sLsiXjZ8EPvCBD9i73vUu27x5s33kIx+xD37wg3bllVfamTNnNnrXxEXOn/zJn9i73vUuGxkZsY985CP27ne/2z7zmc/Yrbfeau12e6N3T1zkqP+JVxOf//zn7YEHHtjo3RA/QTzwwAP2sY99zGq1mu3du3ejd+cVIbHROyBcvvvd79p//s//2T784Q/be9/73o3eHfETRLfbtd/93d+1m2++2b72ta+Z53lmZrZ//35729veZn/6p39q/+bf/JsN3ktxsaL+J15NtNtt+7f/9t/af/gP/8F+7/d+b6N3R/yE8Pa3v90qlYoVi0X7wz/8Q3vsscc2epdeNhftLxvdbtd+7/d+z1772tdaqVSyfD5vb3jDG+y+++77Z5f5oz/6I9u6datls1l74xvfaAcOHHC+c/DgQXvHO95hIyMjlslk7Nprr7UvfvGLL7k/zWbTDh48uCYpwEc/+lGbmpqy3/7t37YwDK1er7/kMuLVxYXa/w4cOGCVSsXuvPPOFx70zMxuv/12KxQK9pnPfOYltyU2HvU/sdFcqH3wh/lv/+2/WRAE9r73vW/Ny4hXBxdy/xsZGbFisfiS37uQuGhfNqrVqn3qU5+yW265xf7gD/7APvCBD9jCwoLddtttkW+Jd911l33sYx+z97znPfY7v/M7duDAAXvzm99s8/PzL3znqaeeshtvvNGeeeYZ+4//8T/ahz/8Ycvn83bHHXfY3Xff/aL789BDD9nevXvt4x//+Evu+z/+4z/addddZx/72MdsfHzcisWiTU9Pr2lZ8ergQu1/nU7HzMyy2azzt2w2a48++qgFQbCGFhAbifqf2Ggu1D74PCdPnrTf//3ftz/4gz+I7I/i1c2F3v8uOsILkD//8z8PzSz83ve+989+x/f9sNPpwGcrKyvh5ORk+Gu/9msvfHbs2LHQzMJsNhuePn36hc8ffPDB0MzC9773vS98duutt4b79u0L2+32C58FQRDu378/3L179wuf3XfffaGZhffdd5/z2fvf//4XPbbl5eXQzMLR0dGwUCiEH/rQh8LPfvaz4c/8zM+EZhZ+4hOfeNHlxeC5mPvfwsJC6Hle+Ou//uvw+cGDB0MzC80sXFxcfNF1iMGi/qf+t9FczH3wed7xjneE+/fvf6E2s/A973nPmpYVg+Unof89z4c+9KHQzMJjx479SMu92rhof9mIx+OWSqXMzCwIAlteXjbf9+3aa6+173//+87377jjDpudnX2hvv766+2GG26wL3/5y2Zmtry8bF//+tftne98p9VqNVtcXLTFxUVbWlqy2267zQ4fPvyi5u1bbrnFwjC0D3zgAy+6389LppaWluxTn/qUve9977N3vvOddu+999pll11mH/zgB3/UphAbwIXa/8bGxuyd73ynffrTn7YPf/jDdvToUfv2t79td955pyWTSTMza7VaP2pziHVG/U9sNBdqHzQzu+++++xv/uZv7KMf/eiPdtDiVcOF3P8uRi7alw0zs09/+tN25ZVXWiaTsdHRURsfH7d7773XVldXne/u3r3b+eySSy55YbqxI0eOWBiG9p/+03+y8fFx+Pf+97/fzMzOnz//svf5+Z9rk8mkveMd73jh81gsZnfeeaedPn3aTp48+bK3IwbPhdj/zMw++clP2lvf+lZ73/veZzt37rSbb77Z9u3bZ29729vMzKxQKLwi2xGDRf1PbDQXYh/0fd9+67d+y37pl37Jrrvuupe9PrFxXIj972Llop2N6i//8i/tV3/1V+2OO+6wf/fv/p1NTExYPB63//pf/6s999xzP/L6ntcJv+9977Pbbrst8ju7du16WftsZi+YjsrlssXjcfjbxMSEmZmtrKzYli1bXva2xOC4UPufmVmpVLK//du/tZMnT9rx48dt69attnXrVtu/f7+Nj49buVx+RbYjBof6n9hoLtQ+eNddd9mzzz5rn/zkJ51sg1qtZsePH7eJiQnL5XIve1ticFyo/e9i5aJ92fjc5z5nO3bssM9//vMwq8nzb6DM4cOHnc8OHTpk27ZtMzOzHTt2mNkPfnH4qZ/6qVd+h/8XsVjMrr76avve975n3W73hZ8BzczOnj1rZmbj4+MD2754ZbhQ+98Ps2XLlhdeaiuVij3yyCP2C7/wC+uybfHyUP8TG82F2gdPnjxpvV7PXv/61zt/u+uuu+yuu+6yu+++2+64446B7YN4+Vyo/e9i5aKVUT3/q0AYhi989uCDD/6z4Txf+MIXQG/30EMP2YMPPmhvectbzOwHvyrccsst9slPftLOnTvnLL+wsPCi+/OjTHt25513Wr/ft09/+tMvfNZut+2v/uqv7LLLLrOZmZmXXIfYWC7k/hfF7/zO75jv+8p9uUBQ/xMbzYXaB3/xF3/R7r77buefmdlb3/pWu/vuu+2GG2540XWIjedC7X8XKxf0Lxt/9md/Zl/5ylecz3/7t3/bbr/9dvv85z9vP//zP28/+7M/a8eOHbNPfOITdtlll0XmVuzatctuuukm+43f+A3rdDr20Y9+1EZHR+3f//t//8J3/vt//+9200032b59++zd73637dixw+bn5+2BBx6w06dP2+OPP/7P7utDDz1kb3rTm+z973//SxqE/vW//tf2qU99yt7znvfYoUOHbMuWLfYXf/EXduLECfvSl7609gYSA+Vi7X+///u/bwcOHLAbbrjBEomEfeELX7CvfvWr9sEPflAa5lcR6n9io7kY++Cll15ql156aeTftm/frl80XkVcjP3PzGx1ddX++I//2MzMvvOd75iZ2cc//nErl8tWLpftN3/zN9fSPK8uNmAGrJfN89Oe/XP/Tp06FQZBEP6X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\n",
            "text/plain": [
              "<Figure size 1000x200 with 5 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "import tensorflow as tf\n",
        "from tensorflow.keras import Model, regularizers\n",
        "from tensorflow.keras.layers import Flatten, Dense, Dropout, Conv2D, MaxPool2D, BatchNormalization, Activation, Input, AveragePooling2D, concatenate\n",
        "from tensorflow.keras.callbacks import ReduceLROnPlateau\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "(train_x, train_y), (test_x, test_y) = tf.keras.datasets.cifar10.load_data()\n",
        "num_classes = 10\n",
        "\n",
        "plt.figure(figsize=(10, 2))\n",
        "for i in range(5):\n",
        "    plt.subplot(1, 5, i + 1)\n",
        "    plt.imshow(train_x[i])\n",
        "    plt.title(f\"Label: {train_y[i][0]}\")\n",
        "    plt.axis('off')\n",
        "plt.show()\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "tGOqhN3irqie"
      },
      "source": [
        "### **1. CIFAR-10 데이터셋의 이미지가 어떤 형태인지 직접 확인**\n",
        "\n",
        "* `train_x[i]`는 `(32, 32, 3)` 크기의 컬러 이미지이며,\n",
        "* `train_y[i][0]`는 그 이미지의 레이블입니다 (0\\~9 사이의 정수)\n",
        "\n",
        "### **2. 이미지와 레이블의 매핑을 이해**\n",
        "\n",
        "* 예: Label 3이면 그것이 ‘고양이’인지, ‘비행기’인지 확인 필요\n",
        "* 이 코드에는 클래스 이름 매핑은 아직 없지만, 이미지를 보고 \"Label 1은 자동차처럼 보이는구나\" 식으로 **직관적 감을 잡기 위함**이에요.\n",
        "\n",
        "### **3. 시각화를 통해 데이터 품질을 빠르게 검토**\n",
        "\n",
        "* 이미지가 깨져있거나 이상하게 라벨링되었는지 확인 가능\n",
        "\n",
        "---\n",
        "모델을 만들기 전에 데이터를 이해하는 단계\n",
        "\n",
        "> CIFAR-10 이미지가 너무 작아서 중요한 특징을 잘 못 담는다면 더 깊은 모델 구조나 데이터 증강이 필요하다는 힌트를 받을 수 있겠지~\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "pzuBeZWTaKrf",
        "outputId": "7e9ffaa4-a52f-4788-8a59-4607c3ce0ce8"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "스케일링 전 픽셀의 최대 값과 최소 값 : 0.0 ~ 0.00392156862745098\n",
            "스케일링 후 픽셀의 최대 값과 최소 값 : 0.0 ~ 1.5378700499807765e-05\n"
          ]
        }
      ],
      "source": [
        "print(f\"스케일링 전 픽셀의 최대 값과 최소 값 : {train_x.min()} ~ {train_x.max()}\")\n",
        "train_x = train_x/255.\n",
        "test_x = test_x/255.\n",
        "print(f\"스케일링 후 픽셀의 최대 값과 최소 값 : {train_x.min()} ~ {train_x.max()}\")\n",
        "\n",
        "image_size = (32, 32)\n",
        "batch_size = 64\n",
        "weight_decay = 5e-4\n",
        "learning_rate = 1e-2\n",
        "epochs = 40\n",
        "\n",
        "def conv2d_bn_relu(x, filters, kernel_size, weight_decay=.0, strides=1):\n",
        "    x = Conv2D(filters=filters,\n",
        "               kernel_size=kernel_size,\n",
        "               strides=strides,\n",
        "               padding='same',\n",
        "               kernel_regularizer=regularizers.l2(weight_decay))(x)\n",
        "    x = BatchNormalization(scale=False, axis=3)(x)\n",
        "    x = Activation('relu')(x)\n",
        "    return x\n",
        "\n",
        "\n",
        "def inception_module(x, filters_num_array, weight_decay=.0):\n",
        "    (br0_filters, br1_filters, br2_filters, br3_filters) = filters_num_array\n",
        "    br0 = conv2d_bn_relu(x, filters=br0_filters, kernel_size=1, weight_decay=weight_decay)\n",
        "    br1 = conv2d_bn_relu(x, filters=br1_filters[0], kernel_size=1, weight_decay=weight_decay)\n",
        "    br1 = conv2d_bn_relu(br1, filters=br1_filters[1], kernel_size=3, weight_decay=weight_decay)\n",
        "    br2 = conv2d_bn_relu(x, filters=br2_filters[0], kernel_size=1, weight_decay=weight_decay)\n",
        "    br2 = conv2d_bn_relu(br2, filters=br2_filters[1], kernel_size=5)\n",
        "    br3 = MaxPool2D(pool_size=3, strides=(1, 1), padding='same')(x)\n",
        "    br3 = conv2d_bn_relu(br3, filters=br3_filters, kernel_size=1, weight_decay=weight_decay)\n",
        "    x = concatenate([br0, br1, br2, br3], axis=3)\n",
        "    return x"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true,
          "base_uri": "https://localhost:8080/"
        },
        "id": "hoop99Yyjp0a",
        "outputId": "449ae50d-1a50-41c4-dd1b-25e7445fe66a"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Epoch 1/40\n",
            "\u001b[1m625/625\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m3921s\u001b[0m 6s/step - accuracy: 0.3960 - loss: 5.4827 - val_accuracy: 0.5557 - val_loss: 4.7608 - learning_rate: 0.0100\n",
            "Epoch 2/40\n",
            "\u001b[1m625/625\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m3887s\u001b[0m 6s/step - accuracy: 0.6530 - loss: 4.4021 - val_accuracy: 0.6583 - val_loss: 4.1082 - learning_rate: 0.0100\n",
            "Epoch 3/40\n",
            "\u001b[1m282/625\u001b[0m \u001b[32m━━━━━━━━━\u001b[0m\u001b[37m━━━━━━━━━━━\u001b[0m \u001b[1m33:44\u001b[0m 6s/step - accuracy: 0.7460 - loss: 3.8073"
          ]
        },
        {
          "ename": "KeyboardInterrupt",
          "evalue": "",
          "output_type": "error",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-8-68862e157fde>\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     78\u001b[0m                               patience=4, min_lr=1e-7, verbose=1)\n\u001b[1;32m     79\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 80\u001b[0;31m history = model.fit(x=train_x, # Changed from googlenet.fit\n\u001b[0m\u001b[1;32m     81\u001b[0m                         \u001b[0my\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtrain_y\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     82\u001b[0m                         \u001b[0mbatch_size\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/keras/src/utils/traceback_utils.py\u001b[0m in \u001b[0;36merror_handler\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    115\u001b[0m         \u001b[0mfiltered_tb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    116\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 117\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    118\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    119\u001b[0m             \u001b[0mfiltered_tb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_process_traceback_frames\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__traceback__\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/keras/src/backend/tensorflow/trainer.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, x, y, batch_size, epochs, verbose, callbacks, validation_split, validation_data, shuffle, class_weight, sample_weight, initial_epoch, steps_per_epoch, validation_steps, validation_batch_size, validation_freq)\u001b[0m\n\u001b[1;32m    369\u001b[0m                 \u001b[0;32mfor\u001b[0m \u001b[0mstep\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0miterator\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mepoch_iterator\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    370\u001b[0m                     \u001b[0mcallbacks\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mon_train_batch_begin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstep\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 371\u001b[0;31m                     \u001b[0mlogs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtrain_function\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    372\u001b[0m                     \u001b[0mcallbacks\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mon_train_batch_end\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstep\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlogs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    373\u001b[0m                     \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstop_training\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/keras/src/backend/tensorflow/trainer.py\u001b[0m in \u001b[0;36mfunction\u001b[0;34m(iterator)\u001b[0m\n\u001b[1;32m    217\u001b[0m                 \u001b[0miterator\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mtf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIterator\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdistribute\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDistributedIterator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    218\u001b[0m             ):\n\u001b[0;32m--> 219\u001b[0;31m                 \u001b[0mopt_outputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmulti_step_on_iterator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    220\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mopt_outputs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhas_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    221\u001b[0m                     \u001b[0;32mraise\u001b[0m \u001b[0mStopIteration\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/util/traceback_utils.py\u001b[0m in \u001b[0;36merror_handler\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    148\u001b[0m     \u001b[0mfiltered_tb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    149\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 150\u001b[0;31m       \u001b[0;32mreturn\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    151\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0mException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    152\u001b[0m       \u001b[0mfiltered_tb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_process_traceback_frames\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__traceback__\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/polymorphic_function/polymorphic_function.py\u001b[0m in \u001b[0;36m__call__\u001b[0;34m(self, *args, **kwds)\u001b[0m\n\u001b[1;32m    831\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    832\u001b[0m       \u001b[0;32mwith\u001b[0m \u001b[0mOptionalXlaContext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_jit_compile\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 833\u001b[0;31m         \u001b[0mresult\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_call\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    834\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    835\u001b[0m       \u001b[0mnew_tracing_count\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexperimental_get_tracing_count\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/polymorphic_function/polymorphic_function.py\u001b[0m in \u001b[0;36m_call\u001b[0;34m(self, *args, **kwds)\u001b[0m\n\u001b[1;32m    876\u001b[0m       \u001b[0;31m# In this case we have not created variables on the first call. So we can\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    877\u001b[0m       \u001b[0;31m# run the first trace but we should fail if variables are created.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 878\u001b[0;31m       results = tracing_compilation.call_function(\n\u001b[0m\u001b[1;32m    879\u001b[0m           \u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variable_creation_config\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    880\u001b[0m       )\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/polymorphic_function/tracing_compilation.py\u001b[0m in \u001b[0;36mcall_function\u001b[0;34m(args, kwargs, tracing_options)\u001b[0m\n\u001b[1;32m    137\u001b[0m   \u001b[0mbound_args\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfunction\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction_type\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbind\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    138\u001b[0m   \u001b[0mflat_inputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfunction\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction_type\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0munpack_inputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbound_args\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 139\u001b[0;31m   return function._call_flat(  # pylint: disable=protected-access\n\u001b[0m\u001b[1;32m    140\u001b[0m       \u001b[0mflat_inputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcaptured_inputs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mfunction\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcaptured_inputs\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    141\u001b[0m   )\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/polymorphic_function/concrete_function.py\u001b[0m in \u001b[0;36m_call_flat\u001b[0;34m(self, tensor_inputs, captured_inputs)\u001b[0m\n\u001b[1;32m   1320\u001b[0m         and executing_eagerly):\n\u001b[1;32m   1321\u001b[0m       \u001b[0;31m# No tape is watching; skip to running the function.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1322\u001b[0;31m       \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_inference_function\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcall_preflattened\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1323\u001b[0m     forward_backward = self._select_forward_and_backward_functions(\n\u001b[1;32m   1324\u001b[0m         \u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/polymorphic_function/atomic_function.py\u001b[0m in \u001b[0;36mcall_preflattened\u001b[0;34m(self, args)\u001b[0m\n\u001b[1;32m    214\u001b[0m   \u001b[0;32mdef\u001b[0m \u001b[0mcall_preflattened\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mSequence\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcore\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTensor\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0mAny\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    215\u001b[0m     \u001b[0;34m\"\"\"Calls with flattened tensor inputs and returns the structured output.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 216\u001b[0;31m     \u001b[0mflat_outputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcall_flat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    217\u001b[0m     \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction_type\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpack_output\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mflat_outputs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    218\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/polymorphic_function/atomic_function.py\u001b[0m in \u001b[0;36mcall_flat\u001b[0;34m(self, *args)\u001b[0m\n\u001b[1;32m    249\u001b[0m         \u001b[0;32mwith\u001b[0m \u001b[0mrecord\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstop_recording\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    250\u001b[0m           \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_bound_context\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexecuting_eagerly\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 251\u001b[0;31m             outputs = self._bound_context.call_function(\n\u001b[0m\u001b[1;32m    252\u001b[0m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    253\u001b[0m                 \u001b[0mlist\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/context.py\u001b[0m in \u001b[0;36mcall_function\u001b[0;34m(self, name, tensor_inputs, num_outputs)\u001b[0m\n\u001b[1;32m   1681\u001b[0m     \u001b[0mcancellation_context\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcancellation\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcontext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1682\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mcancellation_context\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1683\u001b[0;31m       outputs = execute.execute(\n\u001b[0m\u001b[1;32m   1684\u001b[0m           \u001b[0mname\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdecode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"utf-8\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1685\u001b[0m           \u001b[0mnum_outputs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnum_outputs\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.11/dist-packages/tensorflow/python/eager/execute.py\u001b[0m in \u001b[0;36mquick_execute\u001b[0;34m(op_name, num_outputs, inputs, attrs, ctx, name)\u001b[0m\n\u001b[1;32m     51\u001b[0m   \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     52\u001b[0m     \u001b[0mctx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mensure_initialized\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 53\u001b[0;31m     tensors = pywrap_tfe.TFE_Py_Execute(ctx._handle, device_name, op_name,\n\u001b[0m\u001b[1;32m     54\u001b[0m                                         inputs, attrs, num_outputs)\n\u001b[1;32m     55\u001b[0m   \u001b[0;32mexcept\u001b[0m \u001b[0mcore\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_NotOkStatusException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
          ]
        }
      ],
      "source": [
        "import tensorflow as tf\n",
        "from tensorflow.keras import Model, regularizers\n",
        "from tensorflow.keras.layers import Flatten, Dense, Dropout, Conv2D, MaxPool2D, BatchNormalization, Activation, Input, AveragePooling2D, concatenate\n",
        "from tensorflow.keras.callbacks import ReduceLROnPlateau\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Load CIFAR-10 dataset in this cell\n",
        "(train_x, train_y), (test_x, test_y) = tf.keras.datasets.cifar10.load_data()\n",
        "num_classes = 10\n",
        "\n",
        "train_x = train_x/255. # Now train_x is defined before being used\n",
        "test_x = test_x/255.\n",
        "\n",
        "image_size = (32, 32)\n",
        "batch_size = 64\n",
        "weight_decay = 5e-4\n",
        "learning_rate = 1e-2\n",
        "epochs = 40\n",
        "\n",
        "def conv2d_bn_relu(x, filters, kernel_size, weight_decay=.0, strides=1):\n",
        "    x = Conv2D(filters=filters,\n",
        "               kernel_size=kernel_size,\n",
        "               strides=strides,\n",
        "               padding='same',\n",
        "               kernel_regularizer=regularizers.l2(weight_decay))(x)\n",
        "    x = BatchNormalization(scale=False, axis=3)(x)\n",
        "    x = Activation('relu')(x)\n",
        "    return x\n",
        "\n",
        "\n",
        "def inception_module(x, filters_num_array, weight_decay=.0):\n",
        "    (br0_filters, br1_filters, br2_filters, br3_filters) = filters_num_array\n",
        "    br0 = conv2d_bn_relu(x, filters=br0_filters, kernel_size=1, weight_decay=weight_decay)\n",
        "    br1 = conv2d_bn_relu(x, filters=br1_filters[0], kernel_size=1, weight_decay=weight_decay)\n",
        "    br1 = conv2d_bn_relu(br1, filters=br1_filters[1], kernel_size=3, weight_decay=weight_decay)\n",
        "    br2 = conv2d_bn_relu(x, filters=br2_filters[0], kernel_size=1, weight_decay=weight_decay)\n",
        "    br2 = conv2d_bn_relu(br2, filters=br2_filters[1], kernel_size=5)\n",
        "    br3 = MaxPool2D(pool_size=3, strides=(1, 1), padding='same')(x)\n",
        "    br3 = conv2d_bn_relu(br3, filters=br3_filters, kernel_size=1, weight_decay=weight_decay)\n",
        "    x = concatenate([br0, br1, br2, br3], axis=3)\n",
        "    return x\n",
        "\n",
        "def googlenet(input_shape, classes, weight_decay=.0):\n",
        "    input = Input(shape=input_shape)\n",
        "    x = input\n",
        "    x = conv2d_bn_relu(x, filters=64, kernel_size=1, weight_decay=weight_decay)\n",
        "    x = conv2d_bn_relu(x, filters=192, kernel_size=3, weight_decay=weight_decay)\n",
        "    x = MaxPool2D(pool_size=3, strides=2, padding='same')(x)\n",
        "    x = inception_module(x, (64, (96, 128), (16, 32), 32), weight_decay=weight_decay)\n",
        "    x = inception_module(x, (128, (128, 192), (32, 96), 64), weight_decay=weight_decay)\n",
        "    x = MaxPool2D(pool_size=2, strides=2, padding='same')(x)\n",
        "    x = inception_module(x, (192, (96, 208), (16, 48), 64), weight_decay=weight_decay)\n",
        "    x = inception_module(x, (160, (112, 224), (24, 64), 64), weight_decay=weight_decay)\n",
        "    x = inception_module(x, (128, (128, 256), (24, 64), 64), weight_decay=weight_decay)\n",
        "    x = inception_module(x, (112, (144, 288), (32, 64), 64), weight_decay=weight_decay)\n",
        "    x = inception_module(x, (256, (160, 320), (32, 128), 128), weight_decay=weight_decay)\n",
        "    x = MaxPool2D(pool_size=2, strides=2, padding='same')(x)\n",
        "    x = inception_module(x, (256, (160, 320), (32, 128), 128), weight_decay=weight_decay)\n",
        "    x = inception_module(x, (384, (192, 384), (48, 128), 128), weight_decay=weight_decay)\n",
        "    x = AveragePooling2D(pool_size=4, strides=1, padding='valid')(x)\n",
        "    x = Flatten(name='flatten')(x)\n",
        "    output = Dense(classes, activation='softmax')(x)\n",
        "    model = Model(input, output)\n",
        "    return model\n",
        "\n",
        "googlenet = googlenet(input_shape=(image_size[0], image_size[1], 3),\n",
        "                      classes=num_classes,\n",
        "                      weight_decay=weight_decay)\n",
        "\n",
        "optimizer = tf.keras.optimizers.SGD(learning_rate=learning_rate, momentum=0.9)\n",
        "googlenet.compile(optimizer=optimizer,\n",
        "              loss='sparse_categorical_crossentropy',\n",
        "              metrics=[\"accuracy\"])\n",
        "\n",
        "reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5,\n",
        "                              patience=4, min_lr=1e-7, verbose=1)\n",
        "\n",
        "history = googlenet.fit(x=train_x,\n",
        "                        y=train_y,\n",
        "                        batch_size=batch_size,\n",
        "                        epochs=epochs,\n",
        "                        validation_split=0.2,\n",
        "                        callbacks = [reduce_lr])\n",
        "plt.figure(figsize=(14, 5))\n",
        "\n",
        "plt.subplot(1, 2, 1)\n",
        "plt.plot(history.history['loss'], label='Training Loss')\n",
        "plt.plot(history.history['val_loss'], label='Validation Loss')\n",
        "plt.title('Training and Validation Loss')\n",
        "plt.xlabel('Epoch')\n",
        "plt.ylabel('Loss')\n",
        "plt.legend()\n",
        "\n",
        "plt.subplot(1, 2, 2)\n",
        "plt.plot(history.history['accuracy'], label='Training Accuracy')\n",
        "plt.plot(history.history['val_accuracy'], label='Validation Accuracy')\n",
        "plt.title('Training and Validation Accuracy')\n",
        "plt.xlabel('Epoch')\n",
        "plt.ylabel('Accuracy')\n",
        "plt.ylim(0, 1)\n",
        "plt.legend()\n",
        "\n",
        "googlenet.evaluate(test_x, test_y)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "02VRMvW9sAok"
      },
      "source": [
        "### **1. 모델 학습 및 검증 성능 시각화**\n",
        "\n",
        "* `history.history['loss']` vs. `val_loss`\n",
        "* `history.history['accuracy']` vs. `val_accuracy`\n",
        "  → 학습이 잘 진행되었는지, **과적합(overfitting)** 또는 **과소적합(underfitting)** 여부를 시각적으로 확인\n",
        "\n",
        "---\n",
        "\n",
        "### **2. Learning Rate 조절 효과 확인**\n",
        "\n",
        "* `ReduceLROnPlateau`: validation loss가 개선되지 않으면 learning rate를 자동으로 줄임\n",
        "  → 더 빠르게 수렴하거나, local minimum에서 빠져나와 더 나은 성능을 얻도록 유도\n",
        "  → 학습 곡선이 갑자기 더 좋아진다면 LR 감소가 도움이 되었음을 알 수 있음\n",
        "\n",
        "---\n",
        "\n",
        "### **3. 최종 테스트 데이터에 대한 일반화 성능 평가**\n",
        "\n",
        "* `googlenet.evaluate(test_x, test_y)`\n",
        "  → 모델이 학습되지 않은 \\*\\*완전히 새로운 데이터(test set)\\*\\*에 대해 얼마나 잘 작동하는지 **정량적 평가 (loss, accuracy)**\n",
        "\n",
        "---\n",
        "\n",
        "## 📊 그래프를 통해 확인할 수 있는 것\n",
        "\n",
        "| 항목                  | 확인 가능한 내용                             |\n",
        "| ------------------- | ------------------------------------- |\n",
        "| **Training Loss**   | 모델이 학습 데이터에 얼마나 잘 적응했는지               |\n",
        "| **Validation Loss** | 모델이 새로운 데이터에 잘 일반화되고 있는지              |\n",
        "| **Accuracy 그래프**    | 정확도가 점점 높아지는지, 어느 지점에서 plateau에 도달했는지 |\n",
        "| **Loss 곡선 차이**      | 과적합 발생 여부 (train과 val의 차이가 클 경우)      \n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNVM6x71Ickd1/RfYMNYtb/",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
